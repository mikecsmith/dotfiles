#!/usr/bin/env bash
set -e
trap 'echo "An error occurred. Exiting..."' ERR

BUG_TEMPLATE="**Bug Details:**

**Steps to Reproduce:**
1.
2.
3.

**Expected Result:**

**Actual Result:**
"

STORY_TEMPLATE="**Summary:**

**As a** 
**I want** 
**So that** 

**Acceptance Criteria:**

**Given** 
**When** 
**Then** "

TASK_TEMPLATE="**Summary:**

**Acceptance Criteria:**

**Given** 
**When** 
**Then** "

EPIC_TEMPLATE="**Summary:**

**Expected outcome:**

**Goal:**
"

# @cmd Holding command for show tasks
# @meta inherit-flag-options
# @flag -a --any Show issues from any user (removes -a$(jira me) filter)
show() {
  :
}

# @cmd Show all issues
show::all() {
  local filter
  filter=$(get_filter "${argc_any:-}")
  jira issue list --jql "$filter" --plain --columns id,type,summary,status,reporter,assignee | pipe_to_fzf
}

# @cmd Show issues in the current sprint
show::current() {
  local filter
  filter=$(get_filter "${argc_any:-}")
  jira sprint list --table --current --plain --columns=id,type,summary,status,reporter,assignee | pipe_to_fzf
}

# @cmd Show open issues (statuses: Ready for Development, In Progress, In Review)
show::open() {
  local filter
  filter=$(get_filter "${argc_any:-}")
  jira issue list --jql "$filter AND status IN ('Ready for Development', 'In Progress', 'In Review')" --plain --columns id,type,summary,status,reporter,assignee | pipe_to_fzf
}

# @cmd Show backlog issues (statuses: Backlog, Selected for Refinement, Refinement in progress, Refinement in review, Refined)
show::backlog() {
  local filter
  filter=$(get_filter "${argc_any:-}")
  jira issue list --jql "$filter AND status IN ('Backlog', 'Selected for Refinement', 'Refinement in progress', 'Refinement in review', 'Refined')" --plain --columns id,type,summary,status,reporter,assignee | pipe_to_fzf
}

# @cmd Show closed issues (statuses: Done, Wont Do)
show::closed() {
  local filter
  filter=$(get_filter "${argc_any:-}")
  jira issue list --jql "$filter AND status IN ('Done', 'Wont Do')" --plain --columns id,type,summary,status,reporter,assignee | pipe_to_fzf
}

# @cmd Holding command for create tasks
# @meta inherit-flag-options
# @flag -s --sprint Add the issue to the active sprint
# @flag -b --bust Bust the cache
# @option --priority[=Medium|High|Low]
# @option --type[=Task|Epic|Bug|Story|Sub-task|Initiative] Specify the type of issue to create
# @option --parent Specify the parent issue
# @option --status[=Backlog|Refined|Refinement in progress|Refinement in review|Selected for Refinement|In Review|Ready for Development|Done|Wont do]
create() {
  local frontmatter_params

  # shellcheck disable=SC2154,SC2046,SC2086
  if [[ "$argc_type" == "Epic" ]]; then
    frontmatter_params+=("name: ")
  fi

  frontmatter_params+=(
    "summary: "
    "priority: $argc_priority"
    "type: $argc_type"
    "status: $argc_status"
  )

  # shellcheck disable=SC2154,SC2046,SC2086
  [[ "$argc_sprint" -eq 1 ]] && frontmatter_params+=("sprint: true")

  if [[ -n "$argc_parent" ]]; then
    frontmatter_params+=("parent: $argc_parent")
  fi

  local frontmatter
  frontmatter=$(build_frontmatter "${frontmatter_params[@]}")

  local tmpfile
  tmpfile=$(mktemp ~/tmp/jira_create_"$(date +%Y%m%d_%H%M%S)".md)

  echo "$frontmatter" >"$tmpfile"

  if [[ $argc_type == "Epic" ]]; then
    echo "$EPIC_TEMPLATE" >>"$tmpfile"
  elif [[ $argc_type == "Story" ]]; then
    echo "$STORY_TEMPLATE" >>"$tmpfile"
  elif [[ $argc_type == "Task" ]]; then
    echo "$TASK_TEMPLATE" >>"$tmpfile"
  elif [[ $argc_type == "Bug" ]]; then
    echo "$BUG_TEMPLATE" >>"$tmpfile"
  fi

  nvim +2 "$tmpfile"

  local yaml
  yaml=$(awk '/^---/{flag=!flag; next} flag' "$tmpfile")

  local validated_yaml
  validated_yaml=$(validate_with_schema "$HOME/.dotfiles/bin/jira-schema.json" "$yaml")

  local body
  local name
  local parent
  local priority
  local sprint
  local status
  local summary
  local type

  body=$(awk 'BEGIN {found=0} /^---/ {found+=1; next} found==2 {print}' "$tmpfile")
  name=$(echo "$validated_yaml" | yq -r '.name')
  parent=$(echo "$validated_yaml" | yq -r '.parent')
  priority=$(echo "$validated_yaml" | yq -r '.priority')
  sprint=$(echo "$validated_yaml" | yq -r '.sprint')
  status=$(echo "$validated_yaml" | yq -r '.status')
  summary=$(echo "$validated_yaml" | yq -r '.summary')
  type=$(echo "$validated_yaml" | yq -r '.type')

  # Build Jira CLI command parameters
  local jira_params=()

  add_param_if_valid() {
    local param="$1"
    local value="$2"
    if [[ -n "$value" && "$value" != "null" ]]; then
      jira_params+=("$param" "$value")
    fi
  }

  # Add basic parameters
  if [[ "$type" == "Epic" ]]; then
    add_param_if_valid "--name" "$name"
  else
    add_param_if_valid "--type" "$type"
    add_param_if_valid "--parent" "$parent"
  fi

  # Add common parameters - wrap summary in quotes to handle spaces
  add_param_if_valid "--summary" "$summary"
  add_param_if_valid "--priority" "$priority"

  # Add custom fields
  if [[ -n "$JIRA_TEAM" ]]; then
    jira_params+=("--custom" "team=$JIRA_TEAM")
  fi

  # Add sprint if specified
  if [[ "$sprint" == "true" ]]; then
    local sprint_id
    # shellcheck disable=SC2154,SC2046,SC2086
    if [[ "$argc_bust" == "1" ]]; then
      sprint_id=$(get_active_sprint "force")
    else
      sprint_id=$(get_active_sprint)
    fi
    jira_params+=("--custom" "sprint=$sprint_id")
  fi

  # Add --raw flag to get JSON output
  jira_params+=("--raw")

  echo "Creating $type in Jira... with ${jira_params[*]}"
  local jira_output

  if [[ "$type" == "Epic" ]]; then
    jira_output=$(echo "$body" | jira epic create "${jira_params[@]}" 2>&1)
  else
    jira_output=$(echo "$body" | jira issue create "${jira_params[@]}" 2>&1)
  fi

  [[ "$J_DEBUG" = "1" ]] && echo "$jira_output"

  # Extract the issue key from the JSON response if available
  if [[ "$jira_output" =~ \{.*\"key\":\"([^\"]+)\".*\} ]]; then
    local issue_key="${BASH_REMATCH[1]}"
    echo "Created issue: $issue_key"
    echo "URL: $(jira open --no-browser "$issue_key")"
    # Transition the issue if status is provided and not Backlog
    if [[ -n "$status" && "$status" != "null" && "$status" != "Backlog" ]]; then
      echo "Transitioning $issue_key to status: $status"
      jira issue move "$issue_key" "$status" || {
        echo "Warning: Could not transition issue to '$status'. The issue was created successfully."
      }
    fi
  fi
}

# @cmd Debug
# @flag -a --any Show issues from any user (removes -a$(jira me) filter)
debug() {
  echo "sprint: $(get_active_sprint "force")"
  echo "get_filter: $(get_filter "${argc_any:-}")"
}

build_frontmatter() {
  local params=("$@")
  local frontmatter="---"

  for param in "${params[@]}"; do
    if [[ -z "$param" ]]; then
      continue
    fi

    frontmatter+="
$param"
  done

  frontmatter+="
---"
  echo -e "$frontmatter"
}

validate_with_schema() {
  local schema_file="$1"
  local input="$2"

  [[ "$J_DEBUG" = "1" ]] && echo "DEBUG: Starting validation..." >&2
  [[ "$J_DEBUG" = "1" ]] && echo "DEBUG: Schema file: $schema_file" >&2
  [[ "$J_DEBUG" = "1" ]] && echo "DEBUG: Input length: ${#input}" >&2

  # Create a temporary file for the JSON data
  local temp_data_file
  temp_data_file=$(mktemp "$HOME/tmp/jira_frontmatter.yml")
  [[ "$J_DEBUG" = "1" ]] && echo "DEBUG: Temp file created: $temp_data_file" >&2

  if [ ! -f "$temp_data_file" ]; then
    echo "Failed to create temporary file with mktemp: $temp_data_file" >&2
    return 1
  fi

  # Write input to temp file
  echo "$input" >"$temp_data_file"
  [[ "$J_DEBUG" = "1" ]] && echo "DEBUG: Wrote input to temp file" >&2

  # Try basic cat of the file to verify it exists
  [[ "$J_DEBUG" = "1" ]] && echo "DEBUG: File contents:" >&2
  [[ "$J_DEBUG" = "1" ]] && cat "$temp_data_file" >&2

  # Run jsonschema and explicitly capture result
  [[ "$J_DEBUG" = "1" ]] && echo "DEBUG: Running jsonschema..." >&2
  jsonschema validate "$schema_file" "$temp_data_file" >&2
  local result=$?
  [[ "$J_DEBUG" = "1" ]] && echo "DEBUG: jsonschema exit code: $result" >&2

  # Return the file contents and clean up
  cat "$temp_data_file"
  rm -f "$temp_data_file"
  return $result
}

pipe_to_fzf() {
  local fetch_command="jira issue view"
  local input

  input=$(cat)

  local issue_keys
  issue_keys=$(echo "$input" | awk 'NR > 1 {print $1}')

  local me
  me=$(jira me)

  echo "$issue_keys" | xargs -n1 -P4 -I{} bkt --ttl=15m --warm -- bash -c "$fetch_command \"{}\""

  echo "$input" | fzf \
    --ansi \
    --border \
    --padding 1,2 \
    --border-label ' Issues ' --input-label ' Search ' \
    --layout=reverse \
    --header-lines=1 \
    --preview-window=top:60%:wrap \
    --preview="bkt --ttl=15m --stale=1m -- bash -c \"$fetch_command {1}\" | glow --pager never -s dark" \
    --bind='alt-p:toggle-preview' \
    --bind='alt-b:preview-up' \
    --bind='alt-f:preview-down' \
    --bind="alt-a:execute(jira issue assign {1} $me)" \
    --bind='alt-e:execute(jira issue edit {1})' \
    --bind='alt-o:become(jira open {1})' \
    --bind='alt-u:become(jira open --no-browser {1} | pbcopy)' \
    --bind="alt-y:become[jira open --no-browser {1} | awk -F/ '{print \$NF}' | pbcopy ]" \
    --bind='alt-m:execute(jira issue move {1})' \
    --bind='alt-c:execute(nvim /tmp/jira_comment.md -c "set ft=markdown" && jira issue comment add {1} < /tmp/jira_comment.md && rm /tmp/jira_comment.md)'
}

get_filter() {
  local any_flag="$1"

  if [[ "$any_flag" == "1" ]]; then
    local assignees
    read -r -a assignees <<<"${JIRA_TEAM_MEMBERS//,/ }"

    local assignee_filter
    assignee_filter=$(printf ',"%s"' "${assignees[@]}")
    assignee_filter=${assignee_filter:1} # Remove leading comma
    echo "assignee IN ($assignee_filter)"
  else
    echo "assignee = \"$(jira me)\""
  fi
}

get_active_sprint() {
  local force="$1"
  local cache_file="/tmp/active_sprint_cache.json"
  local api_url=$JIRA_ACTIVE_SPRINT_URL

  # Check if the cache should be bypassed
  if [[ "$force" != "force" ]]; then
    # Check if the cache file exists and is valid
    if [[ -f "$cache_file" ]]; then
      local cached_end_date
      cached_end_date=$(jq -r '.endDate' "$cache_file")

      # Check if the cached end date has not passed
      if [[ "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" < "$cached_end_date" ]]; then
        echo "Using cached active sprint:"
        cat "$cache_file"
        return
      fi
    fi
  fi

  # Fetch the active sprint from the API
  local response
  response=$(curl -s -X GET "$api_url" \
    -H "Accept: application/json" \
    -H "Authorization: Basic $JIRA_BEARER_TOKEN")

  # Extract the first sprint from the values array
  local active_sprint
  active_sprint=$(echo "$response" | jq '.values[0]')

  # Cache the result
  echo "$active_sprint" >"$cache_file"

  # Output the active sprint
  echo "$active_sprint" | jq -r '.id'
}

eval "$(argc --argc-eval "$0" "$@")"
