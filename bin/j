#!/usr/bin/env bash

BUG_TEMPLATE="**Bug Details:**

**Steps to Reproduce:**
1.
2.
3.

**Expected Result:**

**Actual Result:**
"

STORY_TEMPLATE="**Summary:**

**As a** 
**I want** 
**So that** 

**Acceptance Criteria:**

**Given** 
**When** 
**Then** "

TASK_TEMPLATE="**Summary:**

**Acceptance Criteria:**

**Given** 
**When** 
**Then** "

EPIC_TEMPLATE="**Summary:**

**Expected outcome:**

**Goal:**
"

# @cmd Holding command for show tasks
# @meta inherit-flag-options
# @flag -a --any Show issues from any user (removes -a$(jira me) filter)
show() {
  :
}

# @cmd Show all issues
show::all() {
  local filter
  filter=$(get_filter "${argc_any:-}")
  jira issue list --jql "$filter" --plain --columns id,summary,status,reporter,assignee | pipe_to_fzf
}

# @cmd Show issues in the current sprint
show::current() {
  local filter
  filter=$(get_filter "${argc_any:-}")
  jira sprint list --jql "$filter" --table --current --plain --columns=id,summary,status,reporter,assignee | pipe_to_fzf
}

# @cmd Show open issues (statuses: Ready for Development, In Progress, In Review)
show::open() {
  local filter
  filter=$(get_filter "${argc_any:-}")
  jira issue list --jql "$filter AND status IN ('Ready for Development', 'In Progress', 'In Review')" --plain --columns id,summary,status,reporter,assignee | pipe_to_fzf
}

# @cmd Show backlog issues (statuses: Backlog, Selected for Refinement, Refinement in progress, Refinement in review, Refined)
show::backlog() {
  local filter
  filter=$(get_filter "${argc_any:-}")
  jira issue list --jql "$filter AND status IN ('Backlog', 'Selected for Refinement', 'Refinement in progress', 'Refinement in review', 'Refined')" --plain --columns id,summary,status,reporter,assignee | pipe_to_fzf
}

# @cmd Show closed issues (statuses: Done, Wont Do)
show::closed() {
  local filter
  filter=$(get_filter "${argc_any:-}")
  jira issue list --jql "$filter AND status IN ('Done', 'Wont Do')" --plain --columns id,summary,status | pipe_to_fzf
}

# @cmd Holding command for create tasks
# @meta inherit-flag-options
# @flag -s --sprint Add the issue to the active sprint
# @flag -b --bust Bust the cache
# @option --priority[=Medium|High|Low]
# @option --type[=Task|Epic|Bug|Story|Sub-task|Initiative] Specify the type of issue to create
# @option --parent Specify the parent issue
# @option --status[=Backlog|Refined|Refinement in progress|Refinement in review|Selected for Refinement|In Review|Ready for Development|Done|Wont do]
create() {
  local frontmatter_params

  if [[ "$argc_type" == "Epic" ]]; then
    frontmatter_params+=("name: ")
  fi

  frontmatter_params+=(
    "summary: "
    "priority: $argc_priority"
    "type: $argc_type"
    "status: $argc_status"
  )

  [[ "$argc_sprint" -eq 1 ]] && frontmatter_params+=("sprint: true")

  if [[ -n "$argc_parent" ]]; then
    frontmatter_params+=("parent: $argc_parent")
  fi

  local frontmatter
  frontmatter=$(build_frontmatter "${frontmatter_params[@]}")

  local tmpfile
  tmpfile=$(mktemp ~/tmp/jira_epic_"$(date +%Y%m%d_%H%M%S)".md)

  echo "$frontmatter" >"$tmpfile"

  if [[ $argc_type == "Epic" ]]; then
    echo "$EPIC_TEMPLATE" >>"$tmpfile"
  elif [[ $argc_type == "Story" ]]; then
    echo "$STORY_TEMPLATE" >>"$tmpfile"
  elif [[ $argc_type == "Task" ]]; then
    echo "$TASK_TEMPLATE" >>"$tmpfile"
  elif [[ $argc_type == "Bug" ]]; then
    echo "$BUG_TEMPLATE" >>"$tmpfile"
  fi

  nvim +2 "$tmpfile" +"normal 9|"

  local yaml
  yaml=$(awk '/^---/{flag=!flag; next} flag' "$tmpfile")

  local validated_yaml
  validated_yaml=$(validate_with_schema_and_extract "$HOME/.dotfiles/bin/jira-schema.json" "$yaml")

  local body
  local name
  local parent
  local priority
  local sprint
  local status
  local summary
  local type

  body=$(awk 'BEGIN {found=0} /^---/ {found+=1; next} found==2 {print}' "$tmpfile")
  name=$(echo "$validated_yaml" | yq -r '.name')
  parent=$(echo "$validated_yaml" | yq -r '.parent')
  priority=$(echo "$validated_yaml" | yq -r '.priority')
  sprint=$(echo "$validated_yaml" | yq -r '.sprint')
  status=$(echo "$validated_yaml" | yq -r '.status')
  summary=$(echo "$validated_yaml" | yq -r '.summary')
  type=$(echo "$validated_yaml" | yq -r '.type')

  echo "Name: $name"
  echo "Parent: $parent"
  echo "Priority: $priority"
  echo "Sprint: $sprint"
  echo "Status: $status"
  echo "Summary: $summary"
  echo "Type: $type"

  # # shellcheck disable=SC2154,SC2046,SC2086
  # if [[ "$argc_sprint" == 1 ]]; then
  #   echo "$body" | jira epic create -n"$name" -s"$summary" -y"$priority" --custom team=$JIRA_TEAM --custom sprint=$(get_active_sprint)
  # elif [[ "$argc_sprint" == 1 && $argc_bust == 1 ]]; then
  #   echo "$body" | jira epic create -n"$name" -s"$summary" -y"$priority" --custom team=$JIRA_TEAM --custom sprint=$(get_active_sprint "force")
  # else
  #   echo "$body" | jira epic create -n"$name" -s"$summary" -y"$priority" --custom team=$JIRA_TEAM
  # fi
}

# @cmd Debug
debug() {
  echo "sprint: $(get_active_sprint "force")"
}

build_frontmatter() {
  local params=("$@")
  local frontmatter="---"

  for param in "${params[@]}"; do
    if [[ -z "$param" ]]; then
      continue
    fi

    frontmatter+="
$param"
  done

  frontmatter+="
---"
  echo -e "$frontmatter"
}

validate_with_schema_and_extract() {
  local schema_file="$1"
  local input="$2"

  # Create a temporary file for the JSON data
  local temp_data_file
  temp_data_file=$(mktemp ~/tmp/jira_frontmatter_xxxx.yml)

  echo "$input" >"$temp_data_file"
  echo "$temp_data_file"
  cat "$temp_data_file"

  # Validate the JSON data using ajv
  ajv validate -s $schema_file -d $temp_data_file
  if [ $? -ne 0 ]; then
    echo "Validation failed. See error above."
    exit 1
  fi

  # Return the validated JSON data
  echo "$input"
}

pipe_to_fzf() {
  local fetch_command="jira issue view"
  local input

  input=$(cat)

  local issue_keys
  issue_keys=$(echo "$input" | awk 'NR > 1 {print $1}')

  echo "$issue_keys" | xargs -n1 -P4 -I{} bkt --ttl=15m --warm -- bash -c "$fetch_command \"{}\""

  echo "$input" | fzf \
    --layout=reverse \
    --header-lines=1 \
    --preview="bkt --ttl=15m --stale=1m -- bash -c $fetch_command {1} -" \
    --bind='alt-p:toggle-preview' \
    --bind='alt-b:preview-up' \
    --bind='alt-f:preview-down' \
    --bind='alt-e:execute(jira issue edit {1})' \
    --bind='alt-o:become(jira open {1})' \
    --bind='alt-u:become(jira open --no-browser {1} | pbcopy)' \
    --bind="alt-y:become[jira open --no-browser {1} | awk -F/ '{print \$NF}' | pbcopy ]" \
    --bind='alt-m:execute(jira issue move {1})' \
    --bind='alt-c:execute(nvim /tmp/jira_comment.md -c "set ft=markdown" && jira issue comment add {1} < /tmp/jira_comment.md && rm /tmp/jira_comment.md)'
}

get_filter() {
  local any_flag="$1"

  # Define an array of assignees
  local assignees=$JIRA_TEAM_MEMBERS

  if [[ "$any_flag" == "1" ]]; then
    local assignee_filter
    assignee_filter=$(printf ',"%s"' "${assignees[@]}")
    assignee_filter=${assignee_filter:1} # Remove leading comma
    echo "assignee IN ($assignee_filter)"
  else
    echo "assignee = \"$(jira me)\""
  fi
}

get_active_sprint() {
  local force="$1"
  local cache_file="/tmp/active_sprint_cache.json"
  local api_url=$JIRA_ACTIVE_SPRINT_URL

  # Check if the cache should be bypassed
  if [[ "$force" != "force" ]]; then
    # Check if the cache file exists and is valid
    if [[ -f "$cache_file" ]]; then
      local cached_end_date
      cached_end_date=$(jq -r '.endDate' "$cache_file")

      # Check if the cached end date has not passed
      if [[ "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" < "$cached_end_date" ]]; then
        echo "Using cached active sprint:"
        cat "$cache_file"
        return
      fi
    fi
  fi

  # Fetch the active sprint from the API
  local response
  response=$(curl -s -X GET "$api_url" \
    -H "Accept: application/json" \
    -H "Authorization: Basic $JIRA_BEARER_TOKEN")

  # Extract the first sprint from the values array
  local active_sprint
  active_sprint=$(echo "$response" | jq '.values[0]')

  # Cache the result
  echo "$active_sprint" >"$cache_file"

  # Output the active sprint
  echo "$active_sprint" | jq -r '.id'
}

eval "$(argc --argc-eval "$0" "$@")"
